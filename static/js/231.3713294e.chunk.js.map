{"version":3,"file":"static/js/231.3713294e.chunk.js","mappings":"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","sources":["component/Layout/CopyrightBottom.js","component/Layout/ProjectHeader.js","hooks/divideArrayIntoChunks.js","../node_modules/react-swipeable/src/index.ts","../node_modules/react-swipeable/src/types.ts","pages/AllView/Project.js","webpack://ppweb/./src/component/Layout/ProjectHeader.module.scss?ebc0","webpack://ppweb/./src/pages/AllView/List&Project.module.scss?5493"],"sourcesContent":["import React from 'react';\r\n\r\nfunction CopyrightBottom() {\r\n  return (\r\n    <div\r\n      style={{\r\n        position: 'relative',\r\n        height: '15vh',\r\n        width: '100vw'\r\n      }}>\r\n      <span\r\n        style={{\r\n          fontSize: 'clamp(0.6rem,1.5vw,0.9rem)',\r\n          position: 'absolute',\r\n          top: '50%',\r\n          left: '50%',\r\n          transform: 'translate(-50%, -50%)',\r\n          textWrap: 'nowrap'\r\n        }}>\r\n        © 2024 Heesu Cho. All Rights Reserved\r\n      </span>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default CopyrightBottom;\r\n","import React from 'react';\r\nimport styles from './ProjectHeader.module.scss';\r\n\r\nfunction Header({ title }) {\r\n  return (\r\n    <>\r\n      <div className={styles.projectHeader}>\r\n        <h1 className={styles.title}>{title}</h1>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default Header;\r\n","import { useState, useEffect } from \"react\";\r\n\r\nconst divideArrayIntoChunks = (array, chunkCount) => {\r\n  const chunks = Array.from({ length: chunkCount }, () => []);\r\n  array.forEach((item, index) => {\r\n    chunks[index % chunkCount].push(item);\r\n  });\r\n  return chunks;\r\n};\r\n\r\nexport const useChunkCount = (initialChunkCount = 4) => {\r\n  const [chunkCount, setChunkCount] = useState(initialChunkCount);\r\n\r\n  useEffect(() => {\r\n    const updateChunkCount = () => {\r\n      const newChunkCount = window.innerWidth <= 768 ? initialChunkCount - 1 : initialChunkCount;\r\n\r\n      if (newChunkCount !== chunkCount) {\r\n        setChunkCount(newChunkCount);\r\n      }\r\n    };\r\n\r\n    window.addEventListener('resize', updateChunkCount);\r\n    updateChunkCount();\r\n\r\n    return () => window.removeEventListener('resize', updateChunkCount);\r\n  }, [initialChunkCount, chunkCount]);\r\n\r\n  return chunkCount;\r\n}\r\n\r\n\r\nexport default divideArrayIntoChunks;","/* global document */\nimport * as React from \"react\";\nimport {\n  AttachTouch,\n  SwipeDirections,\n  DOWN,\n  SwipeEventData,\n  HandledEvents,\n  LEFT,\n  RIGHT,\n  Setter,\n  ConfigurationOptions,\n  SwipeableDirectionCallbacks,\n  SwipeableHandlers,\n  SwipeableProps,\n  SwipeablePropsWithDefaultOptions,\n  SwipeableState,\n  SwipeCallback,\n  TapCallback,\n  UP,\n  Vector2,\n} from \"./types\";\n\nexport {\n  LEFT,\n  RIGHT,\n  UP,\n  DOWN,\n  SwipeDirections,\n  SwipeEventData,\n  SwipeableDirectionCallbacks,\n  SwipeCallback,\n  TapCallback,\n  SwipeableHandlers,\n  SwipeableProps,\n  Vector2,\n};\n\nconst defaultProps: ConfigurationOptions = {\n  delta: 10,\n  preventScrollOnSwipe: false,\n  rotationAngle: 0,\n  trackMouse: false,\n  trackTouch: true,\n  swipeDuration: Infinity,\n  touchEventOptions: { passive: true },\n};\nconst initialState: SwipeableState = {\n  first: true,\n  initial: [0, 0],\n  start: 0,\n  swiping: false,\n  xy: [0, 0],\n};\nconst mouseMove = \"mousemove\";\nconst mouseUp = \"mouseup\";\nconst touchEnd = \"touchend\";\nconst touchMove = \"touchmove\";\nconst touchStart = \"touchstart\";\n\nfunction getDirection(\n  absX: number,\n  absY: number,\n  deltaX: number,\n  deltaY: number\n): SwipeDirections {\n  if (absX > absY) {\n    if (deltaX > 0) {\n      return RIGHT;\n    }\n    return LEFT;\n  } else if (deltaY > 0) {\n    return DOWN;\n  }\n  return UP;\n}\n\nfunction rotateXYByAngle(pos: Vector2, angle: number): Vector2 {\n  if (angle === 0) return pos;\n  const angleInRadians = (Math.PI / 180) * angle;\n  const x =\n    pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);\n  const y =\n    pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);\n  return [x, y];\n}\n\nfunction getHandlers(\n  set: Setter,\n  handlerProps: { trackMouse: boolean | undefined }\n): [\n  {\n    ref: (element: HTMLElement | null) => void;\n    onMouseDown?: (event: React.MouseEvent) => void;\n  },\n  AttachTouch\n] {\n  const onStart = (event: HandledEvents) => {\n    const isTouch = \"touches\" in event;\n    // if more than a single touch don't track, for now...\n    if (isTouch && event.touches.length > 1) return;\n\n    set((state, props) => {\n      // setup mouse listeners on document to track swipe since swipe can leave container\n      if (props.trackMouse && !isTouch) {\n        document.addEventListener(mouseMove, onMove);\n        document.addEventListener(mouseUp, onUp);\n      }\n      const { clientX, clientY } = isTouch ? event.touches[0] : event;\n      const xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n\n      props.onTouchStartOrOnMouseDown &&\n        props.onTouchStartOrOnMouseDown({ event });\n\n      return {\n        ...state,\n        ...initialState,\n        initial: xy.slice() as Vector2,\n        xy,\n        start: event.timeStamp || 0,\n      };\n    });\n  };\n\n  const onMove = (event: HandledEvents) => {\n    set((state, props) => {\n      const isTouch = \"touches\" in event;\n      // Discount a swipe if additional touches are present after\n      // a swipe has started.\n      if (isTouch && event.touches.length > 1) {\n        return state;\n      }\n\n      // if swipe has exceeded duration stop tracking\n      if (event.timeStamp - state.start > props.swipeDuration) {\n        return state.swiping ? { ...state, swiping: false } : state;\n      }\n\n      const { clientX, clientY } = isTouch ? event.touches[0] : event;\n      const [x, y] = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n      const deltaX = x - state.xy[0];\n      const deltaY = y - state.xy[1];\n      const absX = Math.abs(deltaX);\n      const absY = Math.abs(deltaY);\n      const time = (event.timeStamp || 0) - state.start;\n      const velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);\n      const vxvy: Vector2 = [deltaX / (time || 1), deltaY / (time || 1)];\n\n      const dir = getDirection(absX, absY, deltaX, deltaY);\n\n      // if swipe is under delta and we have not started to track a swipe: skip update\n      const delta =\n        typeof props.delta === \"number\"\n          ? props.delta\n          : props.delta[dir.toLowerCase() as Lowercase<SwipeDirections>] ||\n            defaultProps.delta;\n      if (absX < delta && absY < delta && !state.swiping) return state;\n\n      const eventData = {\n        absX,\n        absY,\n        deltaX,\n        deltaY,\n        dir,\n        event,\n        first: state.first,\n        initial: state.initial,\n        velocity,\n        vxvy,\n      };\n\n      // call onSwipeStart if present and is first swipe event\n      eventData.first && props.onSwipeStart && props.onSwipeStart(eventData);\n\n      // call onSwiping if present\n      props.onSwiping && props.onSwiping(eventData);\n\n      // track if a swipe is cancelable (handler for swiping or swiped(dir) exists)\n      // so we can call preventDefault if needed\n      let cancelablePageSwipe = false;\n      if (\n        props.onSwiping ||\n        props.onSwiped ||\n        props[`onSwiped${dir}` as keyof SwipeableDirectionCallbacks]\n      ) {\n        cancelablePageSwipe = true;\n      }\n\n      if (\n        cancelablePageSwipe &&\n        props.preventScrollOnSwipe &&\n        props.trackTouch &&\n        event.cancelable\n      ) {\n        event.preventDefault();\n      }\n\n      return {\n        ...state,\n        // first is now always false\n        first: false,\n        eventData,\n        swiping: true,\n      };\n    });\n  };\n\n  const onEnd = (event: HandledEvents) => {\n    set((state, props) => {\n      let eventData: SwipeEventData | undefined;\n      if (state.swiping && state.eventData) {\n        // if swipe is less than duration fire swiped callbacks\n        if (event.timeStamp - state.start < props.swipeDuration) {\n          eventData = { ...state.eventData, event };\n          props.onSwiped && props.onSwiped(eventData);\n\n          const onSwipedDir =\n            props[\n              `onSwiped${eventData.dir}` as keyof SwipeableDirectionCallbacks\n            ];\n          onSwipedDir && onSwipedDir(eventData);\n        }\n      } else {\n        props.onTap && props.onTap({ event });\n      }\n\n      props.onTouchEndOrOnMouseUp && props.onTouchEndOrOnMouseUp({ event });\n\n      return { ...state, ...initialState, eventData };\n    });\n  };\n\n  const cleanUpMouse = () => {\n    // safe to just call removeEventListener\n    document.removeEventListener(mouseMove, onMove);\n    document.removeEventListener(mouseUp, onUp);\n  };\n\n  const onUp = (e: HandledEvents) => {\n    cleanUpMouse();\n    onEnd(e);\n  };\n\n  /**\n   * The value of passive on touchMove depends on `preventScrollOnSwipe`:\n   * - true => { passive: false }\n   * - false => { passive: true } // Default\n   *\n   * NOTE: When preventScrollOnSwipe is true, we attempt to call preventDefault to prevent scroll.\n   *\n   * props.touchEventOptions can also be set for all touch event listeners,\n   * but for `touchmove` specifically when `preventScrollOnSwipe` it will\n   * supersede and force passive to false.\n   *\n   */\n  const attachTouch: AttachTouch = (el, props) => {\n    let cleanup = () => {};\n    if (el && el.addEventListener) {\n      const baseOptions = {\n        ...defaultProps.touchEventOptions,\n        ...props.touchEventOptions,\n      };\n      // attach touch event listeners and handlers\n      const tls: [\n        typeof touchStart | typeof touchMove | typeof touchEnd,\n        (e: HandledEvents) => void,\n        { passive: boolean }\n      ][] = [\n        [touchStart, onStart, baseOptions],\n        // preventScrollOnSwipe option supersedes touchEventOptions.passive\n        [\n          touchMove,\n          onMove,\n          {\n            ...baseOptions,\n            ...(props.preventScrollOnSwipe ? { passive: false } : {}),\n          },\n        ],\n        [touchEnd, onEnd, baseOptions],\n      ];\n      tls.forEach(([e, h, o]) => el.addEventListener(e, h, o));\n      // return properly scoped cleanup method for removing listeners, options not required\n      cleanup = () => tls.forEach(([e, h]) => el.removeEventListener(e, h));\n    }\n    return cleanup;\n  };\n\n  const onRef = (el: HTMLElement | null) => {\n    // \"inline\" ref functions are called twice on render, once with null then again with DOM element\n    // ignore null here\n    if (el === null) return;\n    set((state, props) => {\n      // if the same DOM el as previous just return state\n      if (state.el === el) return state;\n\n      const addState: { cleanUpTouch?: () => void } = {};\n      // if new DOM el clean up old DOM and reset cleanUpTouch\n      if (state.el && state.el !== el && state.cleanUpTouch) {\n        state.cleanUpTouch();\n        addState.cleanUpTouch = void 0;\n      }\n      // only attach if we want to track touch\n      if (props.trackTouch && el) {\n        addState.cleanUpTouch = attachTouch(el, props);\n      }\n\n      // store event attached DOM el for comparison, clean up, and re-attachment\n      return { ...state, el, ...addState };\n    });\n  };\n\n  // set ref callback to attach touch event listeners\n  const output: { ref: typeof onRef; onMouseDown?: typeof onStart } = {\n    ref: onRef,\n  };\n\n  // if track mouse attach mouse down listener\n  if (handlerProps.trackMouse) {\n    output.onMouseDown = onStart;\n  }\n\n  return [output, attachTouch];\n}\n\nfunction updateTransientState(\n  state: SwipeableState,\n  props: SwipeablePropsWithDefaultOptions,\n  previousProps: SwipeablePropsWithDefaultOptions,\n  attachTouch: AttachTouch\n) {\n  // if trackTouch is off or there is no el, then remove handlers if necessary and exit\n  if (!props.trackTouch || !state.el) {\n    if (state.cleanUpTouch) {\n      state.cleanUpTouch();\n    }\n\n    return {\n      ...state,\n      cleanUpTouch: undefined,\n    };\n  }\n\n  // trackTouch is on, so if there are no handlers attached, attach them and exit\n  if (!state.cleanUpTouch) {\n    return {\n      ...state,\n      cleanUpTouch: attachTouch(state.el, props),\n    };\n  }\n\n  // trackTouch is on and handlers are already attached, so if preventScrollOnSwipe changes value,\n  // remove and reattach handlers (this is required to update the passive option when attaching\n  // the handlers)\n  if (\n    props.preventScrollOnSwipe !== previousProps.preventScrollOnSwipe ||\n    props.touchEventOptions.passive !== previousProps.touchEventOptions.passive\n  ) {\n    state.cleanUpTouch();\n\n    return {\n      ...state,\n      cleanUpTouch: attachTouch(state.el, props),\n    };\n  }\n\n  return state;\n}\n\nexport function useSwipeable(options: SwipeableProps): SwipeableHandlers {\n  const { trackMouse } = options;\n  const transientState = React.useRef({ ...initialState });\n  const transientProps = React.useRef<SwipeablePropsWithDefaultOptions>({\n    ...defaultProps,\n  });\n\n  // track previous rendered props\n  const previousProps = React.useRef<SwipeablePropsWithDefaultOptions>({\n    ...transientProps.current,\n  });\n  previousProps.current = { ...transientProps.current };\n\n  // update current render props & defaults\n  transientProps.current = {\n    ...defaultProps,\n    ...options,\n  };\n  // Force defaults for config properties\n  let defaultKey: keyof ConfigurationOptions;\n  for (defaultKey in defaultProps) {\n    if (transientProps.current[defaultKey] === void 0) {\n      (transientProps.current[defaultKey] as any) = defaultProps[defaultKey];\n    }\n  }\n\n  const [handlers, attachTouch] = React.useMemo(\n    () =>\n      getHandlers(\n        (stateSetter) =>\n          (transientState.current = stateSetter(\n            transientState.current,\n            transientProps.current\n          )),\n        { trackMouse }\n      ),\n    [trackMouse]\n  );\n\n  transientState.current = updateTransientState(\n    transientState.current,\n    transientProps.current,\n    previousProps.current,\n    attachTouch\n  );\n\n  return handlers;\n}\n","import * as React from \"react\";\n\nexport const LEFT = \"Left\";\nexport const RIGHT = \"Right\";\nexport const UP = \"Up\";\nexport const DOWN = \"Down\";\nexport type HandledEvents = React.MouseEvent | TouchEvent | MouseEvent;\nexport type Vector2 = [number, number];\nexport type SwipeDirections =\n  | typeof LEFT\n  | typeof RIGHT\n  | typeof UP\n  | typeof DOWN;\nexport interface SwipeEventData {\n  /**\n   * Absolute displacement of swipe in x. Math.abs(deltaX);\n   */\n  absX: number;\n  /**\n   * Absolute displacement of swipe in y. Math.abs(deltaY);\n   */\n  absY: number;\n  /**\n   * Displacement of swipe in x. (current.x - initial.x)\n   */\n  deltaX: number;\n  /**\n   * Displacement of swipe in y. (current.y - initial.y)\n   */\n  deltaY: number;\n  /**\n   * Direction of swipe - Left | Right | Up | Down\n   */\n  dir: SwipeDirections;\n  /**\n   * Source event.\n   */\n  event: HandledEvents;\n  /**\n   * True for the first event of a tracked swipe.\n   */\n  first: boolean;\n  /**\n   * Location where swipe started - [x, y].\n   */\n  initial: Vector2;\n  /**\n   * \"Absolute velocity\" (speed) - √(absX^2 + absY^2) / time\n   */\n  velocity: number;\n  /**\n   * Velocity per axis - [ deltaX/time, deltaY/time ]\n   */\n  vxvy: Vector2;\n}\n\nexport type SwipeCallback = (eventData: SwipeEventData) => void;\nexport type TapCallback = ({ event }: { event: HandledEvents }) => void;\n\nexport type SwipeableDirectionCallbacks = {\n  /**\n   * Called after a DOWN swipe\n   */\n  onSwipedDown: SwipeCallback;\n  /**\n   * Called after a LEFT swipe\n   */\n  onSwipedLeft: SwipeCallback;\n  /**\n   * Called after a RIGHT swipe\n   */\n  onSwipedRight: SwipeCallback;\n  /**\n   * Called after a UP swipe\n   */\n  onSwipedUp: SwipeCallback;\n};\n\nexport type SwipeableCallbacks = SwipeableDirectionCallbacks & {\n  /**\n   * Called at start of a tracked swipe.\n   */\n  onSwipeStart: SwipeCallback;\n  /**\n   * Called after any swipe.\n   */\n  onSwiped: SwipeCallback;\n  /**\n   * Called for each move event during a tracked swipe.\n   */\n  onSwiping: SwipeCallback;\n  /**\n   * Called after a tap. A touch under the min distance, `delta`.\n   */\n  onTap: TapCallback;\n  /**\n   * Called for `touchstart` and `mousedown`.\n   */\n  onTouchStartOrOnMouseDown: TapCallback;\n  /**\n   * Called for `touchend` and `mouseup`.\n   */\n  onTouchEndOrOnMouseUp: TapCallback;\n};\n\n// Configuration Options\nexport type ConfigurationOptionDelta =\n  | number\n  | { [key in Lowercase<SwipeDirections>]?: number };\n\nexport interface ConfigurationOptions {\n  /**\n   * Min distance(px) before a swipe starts. **Default**: `10`\n   */\n  delta: ConfigurationOptionDelta;\n  /**\n   * Prevents scroll during swipe in most cases. **Default**: `false`\n   */\n  preventScrollOnSwipe: boolean;\n  /**\n   * Set a rotation angle. **Default**: `0`\n   */\n  rotationAngle: number;\n  /**\n   * Track mouse input. **Default**: `false`\n   */\n  trackMouse: boolean;\n  /**\n   * Track touch input. **Default**: `true`\n   */\n  trackTouch: boolean;\n  /**\n   * Allowable duration of a swipe (ms). **Default**: `Infinity`\n   */\n  swipeDuration: number;\n  /**\n   * Options for touch event listeners\n   */\n  touchEventOptions: { passive: boolean };\n}\n\nexport type SwipeableProps = Partial<SwipeableCallbacks & ConfigurationOptions>;\n\nexport type SwipeablePropsWithDefaultOptions = Partial<SwipeableCallbacks> &\n  ConfigurationOptions;\n\nexport interface SwipeableHandlers {\n  ref(element: HTMLElement | null): void;\n  onMouseDown?(event: React.MouseEvent): void;\n}\n\nexport type SwipeableState = {\n  cleanUpTouch?: () => void;\n  el?: HTMLElement;\n  eventData?: SwipeEventData;\n  first: boolean;\n  initial: Vector2;\n  start: number;\n  swiping: boolean;\n  xy: Vector2;\n};\n\nexport type StateSetter = (\n  state: SwipeableState,\n  props: SwipeablePropsWithDefaultOptions\n) => SwipeableState;\nexport type Setter = (stateSetter: StateSetter) => void;\nexport type AttachTouch = (\n  el: HTMLElement,\n  props: SwipeablePropsWithDefaultOptions\n) => () => void;\n","/* eslint-disable jsx-a11y/img-redundant-alt */\r\nimport React, { Suspense, lazy, useEffect, useState } from 'react';\r\nimport { useParams, useNavigate } from 'react-router-dom';\r\nimport { useSwipeable } from 'react-swipeable';\r\nimport LazyLoad from 'react-lazyload';\r\nimport styles from './List&Project.module.scss';\r\nimport imageCountData from '../../data/imageCount.json';\r\nimport divideArrayIntoChunks, { useChunkCount } from '../../hooks/divideArrayIntoChunks';\r\nimport Header from '../../component/Layout/ProjectHeader';\r\nimport CopyrightBottom from '../../component/Layout/CopyrightBottom';\r\n\r\nconst SlideAlert = lazy(() => import('../../component/Alert/SlideAlert'));\r\n\r\nfunction Project() {\r\n  const navigate = useNavigate();\r\n  const goBack = () => navigate(`/list?category=${encodeURIComponent(category)}`);\r\n\r\n  const { title, category } = useParams();\r\n  const [images, setImages] = useState([]);\r\n  const [slideIsOpen, setSlideIsOpen] = useState(false);\r\n  const [currentImageIndex, setcurrentImageIndex] = useState(0);\r\n  const [showGrid, setShowGrid] = useState(true);\r\n\r\n  useEffect(() => {\r\n    const imagesCount = imageCountData[category][title];\r\n    const imagePaths = Array.from(\r\n      { length: imagesCount },\r\n      (_, index) => `${process.env.PUBLIC_URL}/imgs/${category}/${title}/${index + 1}.webp`\r\n    );\r\n\r\n    const loadImages = async () => {\r\n      const validImages = await Promise.all(imagePaths.map(async (path, index) => {\r\n        try {\r\n          const img = new Image();\r\n          img.src = path;\r\n          await img.decode();\r\n          return { img: path, title: `image${index + 1}` };\r\n        } catch (error) {\r\n          console.log(`Image not found: ${path}`);\r\n          return null;\r\n        }\r\n      }));\r\n\r\n      setImages(validImages.filter(Boolean));\r\n    };\r\n\r\n    loadImages();\r\n  }, [title, category]);\r\n\r\n  const openSlide = (index) => {\r\n    setcurrentImageIndex(index);\r\n    setSlideIsOpen(true);\r\n  }\r\n\r\n  const nextImage = () => {\r\n    setcurrentImageIndex((prevIndex) => (prevIndex + 1) % images.length);\r\n  }\r\n\r\n  const prevImage = () => {\r\n    setcurrentImageIndex((prevIndex) => (prevIndex - 1 + images.length) % images.length);\r\n  }\r\n\r\n  const toggleGrid = () => {\r\n    setShowGrid((prevShowGrid) => !prevShowGrid);\r\n    setSlideIsOpen((prevSlideIsOpen) => !prevSlideIsOpen);\r\n  };\r\n\r\n  const handleOnClick = (chunkIndex, chunkCount, index) => {\r\n    toggleGrid(false);\r\n    openSlide(chunkIndex + chunkCount * index);\r\n  };\r\n\r\n  const handlers = useSwipeable({\r\n    onSwipedLeft: nextImage,\r\n    onSwipedRight: prevImage,\r\n    preventDefaultTouchmoveEvent: true,\r\n    trackMouse: true,\r\n  });\r\n\r\n  const chunkCount = useChunkCount();\r\n  const chunkedImages = divideArrayIntoChunks(images, chunkCount);\r\n\r\n  return (\r\n    <>\r\n      <Header title={title}></Header>\r\n\r\n      <div className={styles.buttons}>\r\n        <p onClick={goBack}>\r\n          <svg\r\n            xmlns=\"http://www.w3.org/2000/svg\"\r\n            viewBox=\"0 0 24 24\"\r\n            stroke=\"currentColor\"\r\n            strokeWidth=\"4\"\r\n            className={`h-6 w-6 ${styles.arrowIcon}`}>\r\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" d=\"M14 5l7 7m0 0l-7 7m7-7H3\"></path>\r\n          </svg> Back To List</p>\r\n        <p onClick={toggleGrid} className={`${showGrid ? styles.active : ''}`}>View Grid</p>\r\n      </div>\r\n\r\n      {(showGrid && !slideIsOpen) && (\r\n        <div className={styles.gridContainer}>\r\n          {chunkedImages.map((chunk, chunkIndex) => (\r\n            <div key={`column-${chunkIndex}`} className={styles.imageColumn}>\r\n              {chunk.map((image, index) => (\r\n                <div key={`image-${chunkIndex}-${index}`} className={styles.imgContainer}>\r\n                  <LazyLoad>\r\n                    <img\r\n                      key={index}\r\n                      src={image.img}\r\n                      alt={image.title}\r\n                      onClick={() => handleOnClick(chunkIndex, chunkCount, index)}\r\n                      className={styles.gridImg}\r\n                    />\r\n                  </LazyLoad>\r\n                </div>\r\n              ))}\r\n            </div>\r\n          ))}\r\n        </div>\r\n      )}\r\n\r\n      {(!showGrid && slideIsOpen) && (\r\n        <>\r\n          <div className={styles.slideContainer} {...handlers}>\r\n            <Suspense fallback={<div>Loading alert...</div>}>\r\n              <SlideAlert direction=\"horizontal\" storageKey=\"projectPageAlertShown\" />\r\n            </Suspense>\r\n            <button onClick={prevImage} className={`${styles.arrow} ${styles.leftArrow}`}>&lt;</button>\r\n            <img src={images[currentImageIndex]?.img} alt={`image ${currentImageIndex + 1}`} />\r\n            <button onClick={nextImage} className={`${styles.arrow} ${styles.rightArrow}`}>&gt;</button>\r\n          </div>\r\n          <div className={styles.slideIndex}><p>{currentImageIndex + 1} / {images.length}</p></div>\r\n        </>\r\n      )}\r\n\r\n      <CopyrightBottom></CopyrightBottom>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default Project;\r\n","// extracted by mini-css-extract-plugin\nexport default {\"projectHeader\":\"ProjectHeader_projectHeader__hdWRZ\",\"title\":\"ProjectHeader_title__SLl8W\"};","// extracted by mini-css-extract-plugin\nexport default {\"buttons\":\"List&Project_buttons__Aqb7I\",\"active\":\"List&Project_active__NP8no\",\"arrowIcon\":\"List&Project_arrowIcon__vzqcz\",\"gridContainer\":\"List&Project_gridContainer__5De81\",\"imageColumn\":\"List&Project_imageColumn__PKqne\",\"gridImg\":\"List&Project_gridImg__oqV7X\",\"slideContainer\":\"List&Project_slideContainer__xDb5q\",\"slideIndex\":\"List&Project_slideIndex__R2fK4\",\"imgContainer\":\"List&Project_imgContainer__LcxKh\",\"projectInfo\":\"List&Project_projectInfo__lVS2u\",\"arrow\":\"List&Project_arrow__Ab5VS\",\"leftArrow\":\"List&Project_leftArrow__ZtDMK\",\"rightArrow\":\"List&Project_rightArrow__6413n\"};"],"names":["_jsx","style","position","height","width","children","fontSize","top","left","transform","textWrap","_ref","title","_Fragment","className","styles","projectHeader","useChunkCount","initialChunkCount","arguments","length","undefined","chunkCount","setChunkCount","useState","useEffect","updateChunkCount","newChunkCount","window","innerWidth","addEventListener","removeEventListener","divideArrayIntoChunks","array","chunks","Array","from","forEach","item","index","push","defaultProps","delta","preventScrollOnSwipe","rotationAngle","trackMouse","trackTouch","swipeDuration","Infinity","touchEventOptions","passive","initialState","first","initial","start","swiping","xy","mouseMove","mouseUp","rotateXYByAngle","pos","angle","angleInRadians","Math","PI","cos","sin","getHandlers","set","handlerProps","onStart","event","isTouch","touches","state","props","document","onMove","onUp","clientX","clientY","onTouchStartOrOnMouseDown","Object","assign","slice","timeStamp","x","y","deltaX","deltaY","absX","abs","absY","time","velocity","sqrt","vxvy","dir","getDirection","toLowerCase","eventData","onSwipeStart","onSwiping","cancelablePageSwipe","onSwiped","cancelable","preventDefault","onEnd","onSwipedDir","onTap","onTouchEndOrOnMouseUp","e","attachTouch","el","cleanup","baseOptions","tls","h","o","_ref2","output","ref","addState","cleanUpTouch","onMouseDown","useSwipeable","options","transientState","React","transientProps","previousProps","current","defaultKey","handlers","stateSetter","updateTransientState","SlideAlert","lazy","_images$currentImageI","navigate","useNavigate","category","useParams","images","setImages","slideIsOpen","setSlideIsOpen","currentImageIndex","setcurrentImageIndex","showGrid","setShowGrid","imagesCount","imageCountData","imagePaths","_","async","validImages","Promise","all","map","path","img","Image","src","decode","error","console","log","filter","Boolean","loadImages","nextImage","prevIndex","prevImage","toggleGrid","prevShowGrid","prevSlideIsOpen","handleOnClick","chunkIndex","openSlide","onSwipedLeft","onSwipedRight","preventDefaultTouchmoveEvent","chunkedImages","_jsxs","Header","buttons","onClick","goBack","encodeURIComponent","xmlns","viewBox","stroke","strokeWidth","arrowIcon","strokeLinecap","strokeLinejoin","d","active","gridContainer","chunk","imageColumn","image","imgContainer","LazyLoad","alt","gridImg","slideContainer","Suspense","fallback","direction","storageKey","arrow","leftArrow","rightArrow","slideIndex","CopyrightBottom"],"sourceRoot":""}